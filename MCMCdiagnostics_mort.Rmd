---
 title: "MCMC diagnostics - Mortality"
 subtitle: "Test v18.0 - plot and year random effect - Size and basal area competition fixed effect"
 author: "Will Vieira"
 date: "`r paste('Last updated on', format(Sys.time(), '%d %B, %Y'))`"
---


## Diagnostics mortality model

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

```{r, echo = F, message=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(cmdstanr))
suppressPackageStartupMessages(library(loo))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(tidybayes))
suppressPackageStartupMessages(library(bayesplot))
suppressPackageStartupMessages(library(ggridges))
suppressPackageStartupMessages(require(RColorBrewer))
suppressPackageStartupMessages(library(DT))
suppressPackageStartupMessages(library(corrr))
```


```{r load simulations, echo = F}
# Load simulation variables
simInfo <- yaml::read_yaml('_simulation_info.yml')

spIds <- simInfo$spIds
simName <- simInfo$simName
simulations <- simInfo$simulations

# List output files and set vector names to species_id
posteriopsiPop_files <- grep(
  'posteriorPop',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(posteriopsiPop_files) <- names(sort(sapply(spIds, function(x) grep(x, posteriopsiPop_files))))

posteriorpsiPlot_files <- grep(
  'posteriorpsiPlot',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(posteriorpsiPlot_files) <- names(sort(sapply(spIds, function(x) grep(x, posteriorpsiPlot_files))))

posteriorpsiYear_files <- grep(
  'posteriorpsiYear_',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(posteriorpsiYear_files) <- names(sort(sapply(spIds, function(x) grep(x, posteriorpsiYear_files))))
posteriorpsiYearInt_files <- grep(
  'posteriorpsiYearInt_',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(posteriorpsiYearInt_files) <- names(sort(sapply(spIds, function(x) grep(x, posteriorpsiYearInt_files))))

diag_files <- grep(
  'diagnostics',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(diag_files) <- names(sort(sapply(spIds, function(x) grep(x, diag_files))))

trainData_files <- grep(
  'trainData',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(trainData_files) <- names(sort(sapply(spIds, function(x) grep(x, trainData_files))))

timeInterval_files <- grep(
  'timeInterval',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(timeInterval_files) <- names(sort(sapply(spIds, function(x) grep(x, timeInterval_files))))
```

```{r load dataset,echo =FALSE}
trainData <- map2_dfr(
  trainData_files,
  names(trainData_files),
  ~ readRDS(.x)
)

timeInterval <- map2_dfr(
  timeInterval_files,
  names(timeInterval_files),
  ~ readRDS(.x) |>
    bind_cols(species_id = .y)
)

mort_dt <- readRDS('data/mort_dt.RDS')
mort_dt <- mort_dt[species_id %in% spIds]

# merge with train data
mort_dt[
  trainData,
  sampled := i.sampled,
  on = c('tree_id', 'year0')
]
mort_dt[
  timeInterval,
  time_int := i.time_int,
  on = c('year0' = 'year0', 'year1' = 'year1', 'species_id' = 'species_id')
]

# add species_id to trainData
trainData[
  mort_dt,
  `:=`(
    'plot_id' = i.plot_id,
    'species_id' = i.species_id,
    'deltaYear' = i.deltaYear,
    'mort' = i.mort,
    'dbh0' = i.dbh0,
    'BA_comp_sp' = i.BA_comp_sp,
    'BA_comp_intra' = i.BA_comp_intra,
    'BA_plot' = i.BA_plot,
    'bio_01_mean' = i.bio_01_mean,
    'bio_12_mean' = i.bio_12_mean
  ),
  on = c('tree_id', 'year0')
]
trainData[
  timeInterval,
  time_int := i.time_int,
  on = c('year0' = 'year0', 'species_id' = 'species_id')
]
# summary by plot_id and tree_id
plot_id_summary <- mort_dt[, 
    .(
      latitude = unique(latitude),
      BA_plot = mean(BA_plot),
      bio_01_mean = mean(bio_01_mean),
      bio_12_mean = mean(bio_12_mean)
    ), 
    by = plot_id
  ]

tree_id_summary <- mort_dt[, 
    .(
      plot_id = unique(plot_id),
      dbh0 = mean(dbh0, na.rm = TRUE),
      BA_comp = mean(BA_comp, na.rm = TRUE),
      bio_01_mean = mean(bio_01_mean, na.rm = TRUE)
    ), 
    by = tree_id
  ]
```

# Rhat

```{r rhat, echo = F, fig.height = 7, fig.width = 7}
map2_dfr(
  diag_files,
  names(diag_files),
  ~ readRDS(.x)[['rhat']] |>
      bind_cols(species_id = .y)
) |>
ggplot(aes(x = rhat, y = species_id)) +
  geom_boxplot() +
  theme_minimal()
```



# Divergent transitions

```{r divergentTransitions, echo = FALSE}
map2_dfr(
  diag_files,
  names(diag_files),
  ~ readRDS(.x)[['diag_summary']]['num_divergent'] |>
      bind_cols(species_id = .y) |>
      mutate(chain = row_number())
) |>
pivot_wider(
  names_from = chain,
  values_from = num_divergent,
  names_prefix = 'chain '
) |>
DT::datatable()
```



# Posterior distribution of parameters

```{r posteriorDist, eval = TRUE,echo = F, fig.height = 7, fig.width = 8}
post <- map2_dfr(
  posteriopsiPop_files,
  names(posteriopsiPop_files),
  ~ readRDS(.x) |>
    bind_cols(species_id = .y)
)

nIter = simInfo$maxIter * simInfo$nC/2

post_prior <- post |>
  bind_rows(
    tibble(
      par = unique(post$par),
      species_id = 'prior'
    ) |>
    expand_grid(iter = 1:nIter) |>
    group_by(par) |>
    mutate(
      value = case_when(
        par == 'psi' ~ rnorm(nIter, 3, 1),
        par == 'sigma_plot' ~ rexp(nIter, 2),
        par == 'sigma_year' ~ rexp(nIter, 2),
        par == 'size_opt' ~ rnorm(nIter, 250, 100),
	      par == 'size_var' ~ rlnorm(nIter, 1, 1),
        par == 'Beta' ~ rnorm(nIter, 0, .1),
        par == 'theta' ~ rexp(nIter, 2.5)
      )
    )
  )

for(Par in unique(post$par))
{
  print(
    post_prior |>
      filter(par == Par) |>
      ggplot(aes(x = value, y = species_id)) +
        stat_eye() +
        ggtitle(Par) +
        xlab('') +
        theme_minimal()
  )
}
```


# Correlation between parameters

```{r parCorrelation, eval = TRUE,echo = F, fig.height = 8, fig.width = 8}
parComb <- post |>
  summarise(uqPar = unique(par)) |>
  pull(uqPar) |>
  combn(2)

for(i in 1:ncol(parComb))
{
  print(
    post |>
      filter(par %in% parComb[, i]) |>
      filter(iter %in% sample(iter, 1000)) |>
      select(par, value, iter, species_id) |>
      pivot_wider(names_from = par, values_from = value) |>
      ggplot(aes_string(x = parComb[1, i], y = parComb[2, i])) + 
          geom_point() +
          facet_wrap(~ species_id) +
          xlab(parComb[1, i]) +
          ylab(parComb[2, i]) +
          theme_minimal()
  )
}
```


# Random effect

```{r plot_randomEffect, eval = TRUE, warning=FALSE, message=FALSE,echo = F, fig.height = 8, fig.width = 8}
plotEffect_ls <- yearEffect_ls <- list()
for(Sp in spIds)
{
    psi_pop <- post |>
      filter(species_id == Sp & par == 'psi') |>
      mutate(psi_pop = value) |>
      select(psi_pop, iter)
    psi_mean <- psi_pop |>
      summarise(psi_mean = mean(exp(psi_pop))) |>
      pull(psi_mean)
    dt_toPlot <- readRDS(posteriorpsiPlot_files[Sp]) |>
      mutate(plot_id_seq = parse_number(par)) |>
      left_join(
        psi_pop
      ) |>
      mutate(
        psiPlot = value,
        psi_natural = exp(psiPlot + psi_pop)
      ) |>
      select(!value) |>
      left_join(
        trainData[
          species_id == Sp & !is.na(plot_id_seq),
          .(plot_id = unique(plot_id)),
          by = plot_id_seq
        ]
      ) |>
      left_join(
        plot_id_summary
      )
    
    # prepare timeInterval info
    yearRange <- timeInterval[species_id == Sp, range(c(year0, year1))]
    yearSeq_id <- data.table(
      year = seq(yearRange[1], yearRange[2]),
      year_id = 1:length(seq(yearRange[1], yearRange[2])
      )
    )
    
    dt_toYear <- readRDS(posteriorpsiYear_files[Sp]) |>
      mutate(year_id = parse_number(par)) |>
      left_join(
        psi_pop
      ) |>
      mutate(psi_natural = exp(value + psi_pop)) |>
      left_join(
        yearSeq_id
      )
    
    # save plot effect mean to plot against other variables
    # in the next code block
    plotEffect_ls[[Sp]] <- dt_toPlot |>
        group_by(par) |>
        mutate(
          psi_natural_mean = mean(psi_natural),
          psi_pop = exp(psi_pop)
        ) |>
        ungroup() |>
        filter(iter == 1) |>
        select(
          plot_id, plot_id_seq, psi_pop, psi_natural_mean, latitude,
          BA_plot, bio_01_mean, bio_12_mean
        )
    yearEffect_ls[[Sp]] <- dt_toYear |>
        group_by(par) |>
        mutate(
          psi_natural_mean = mean(psi_natural),
          psi_pop = exp(psi_pop)
        ) |>
        ungroup() |>
        filter(iter == 1) |>
        select(
          year, year_id, psi_pop, psi_natural_mean
        )
    print(
      ggarrange(
        dt_toPlot |>
            filter(plot_id_seq %in% sample(plot_id_seq, 800)) |>
            mutate(plot_id = fct_reorder(plot_id, latitude)) |>
            ggplot(aes(y = plot_id, x = psi_natural, color = bio_01_mean)) +
              stat_pointinterval(alpha = .7, size = .1) +
              geom_vline(
                xintercept = psi_mean, color = 'red', alpha = .8
              ) +
              xlab('Longevity (years)') +
              ylab('plot_id (ordered by latitude)') +
              theme(
                legend.position = 'top',
                axis.text.y = element_blank()
              ) +
              labs(subtitle = Sp),
        dt_toYear |>
            mutate(year = factor(year)) |>
            ggplot(aes(y = year, x = log(psi_natural))) +
              stat_pointinterval(alpha = .7, size = .1) +
              geom_vline(
                xintercept = log(psi_mean), color = 'red', alpha = .8
              ) +
              xlab('Longetivity (log scale)') +
              ylab('Year') +
              theme(
                legend.position = 'none'
              ) +
              labs(subtitle = ''),
        ncol = 2
    )
    )
}
# save plot effect ot be used against future models
plotEffect <- plotEffect_ls |>
  bind_rows(.id = 'species_id')
plotEffect |>
  select(species_id, plot_id, psi_natural_mean) |>
  saveRDS(
    file.path(
        'output', 
        simName,
        'meanPlotEffect_psi.RDS'
    )
  )
yearEffect <- yearEffect_ls |>
  bind_rows(.id = 'species_id')
yearEffect |>
  select(species_id, year, year_id, psi_pop, psi_natural_mean) |>
  saveRDS(
    file.path(
        'output', 
        simName,
        'meanYearEffect_psi.RDS'
    )
  )
```


# Correlation in plot random effects between species

```{r corrPlotEffect, echo = FALSE, warning=FALSE, message=FALSE,fig.height=8, fig.width = 8}

# load parameters
post_mean <- post |>
  filter(par == 'psi') |>
  group_by(species_id) |>
  summarise(psi = mean(value))

psiPlot_mean <- readRDS(
  file.path('output', simName, 'meanPlotEffect_psi.RDS')
  ) |>
  left_join(
    post_mean
  ) |>
  mutate(
    psiPlot = log(psi_natural_mean) - psi
  )

psiPlot_mean |>
  mutate(species_id = gsub('[0-9]', '', species_id)) |>
  select(species_id, plot_id, psiPlot) |>
  pivot_wider(
    names_from = species_id,
    values_from = psiPlot
  ) |>
  select(!plot_id) |>
  correlate(quiet = TRUE) |>
  rplot() +
  scale_color_gradient2(limits = c(-1,1)) +
  #labs(title = 'Correlation of plot random effects between species')
  theme(
    legend.position = 'bottom',
    axis.text.x = element_text(angle = 45, vjust = 0.4),
  )
```


# Correlation in year random effects between species

```{r corrYearEffect, echo = FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width = 8}
# load parameters
post_mean <- post |>
  filter(par == 'psi') |>
  group_by(species_id) |>
  summarise(psi = mean(value))
psiYear_mean <- readRDS(
  file.path('output', simName, 'meanYearEffect_psi.RDS')
  ) |>
  left_join(
    post_mean
  ) |>
  mutate(
    psiYear = log(psi_natural_mean) - psi
  )
psiYear_mean |>
  mutate(species_id = gsub('[0-9]', '', species_id)) |>
  select(species_id, year, psiYear) |>
  pivot_wider(
    names_from = species_id,
    values_from = psiYear
  ) |>
  select(!year) |>
  correlate(use = 'na.or.complete', quiet = TRUE) |>
  rplot() +
  scale_color_gradient2(limits = c(-1,1)) +
  #labs(title = 'Correlation of year random effects between species') +
  theme(
    legend.position = 'bottom',
    axis.text.x = element_text(angle = 45, vjust = 0.4),
  )
```

# Changes in plot random effect from past models

Compare plot random effect with last model to check how variance is changing. 

```{r compare_rReal, echo = FALSE, warning=FALSE, message=FALSE, fig.height = 8, fig.width = 12}
sim_to_compare <- simInfo$simCompare

for(Sim in sim_to_compare)
{
  sim_toLoad <- c(Sim, simName)
    
  print(
    map_dfr(
      sim_toLoad,
      ~ readRDS(file.path('output', .x, 'meanPlotEffect_psi.RDS')) |>
        bind_cols(sim = .x)
    ) |>
    pivot_wider(
      names_from = sim,
      values_from = psi_natural_mean
    ) |>
    ggplot(aes(x = !!sym(sim_toLoad[1]), y = !!sym(sim_toLoad[2]))) +
      geom_point(size = 0.8, alpha = .7) +
      geom_abline(intercept = 0, slope = 1) +
      #tune::coord_obs_pred() +
      facet_wrap(~species_id, scales = 'free') +
      theme_minimal()
  )
}
```


# Data distribution

```{r organize data, echo = FALSE, warning=FALSE, message=FALSE, fig.height = 10, fig.width = 8}
# split between train and everything else (merge validate with rest of data)
mort_dt[, sampled2 := sampled]
mort_dt[is.na(sampled), sampled2 := 'validation']

mort_dt[, .(species_id, dbh0, deltaYear, BA_comp_sp, BA_comp_intra, bio_01_mean, bio_12_mean, sampled2)] |>
  mutate(sample = sampled2) |>
  pivot_longer(
    cols = c(dbh0, deltaYear, BA_comp_sp, BA_comp_intra, bio_01_mean, bio_12_mean),
    names_to = 'var'
  ) |>
  ggplot(aes(x = value, y = species_id, fill = sample)) +
    geom_density_ridges(alpha = 0.7, color = NA) +
    facet_wrap(~var, scales = 'free_x') +
    xlab('') +
    theme_minimal() +
    theme(legend.position = 'top')
```



# Predictions

## Species longevitity `intercept: exp(psi)`

```{r sizePred,echo=FALSE,warning=FALSE, message=FALSE,fig.height = 6.5, fig.width = 7}
post |>
  filter(par == 'psi') |>
  mutate(long = exp(value)) |>
  ggplot(aes(x = long, y = species_id)) +
    ggridges::geom_density_ridges2() +
    theme_minimal() +
    xlab('Longevity (years)')
```


## Size effect

```{r SizeEffect,echo=FALSE,warning=FALSE,message=FALSE,fig.height=8,fig.width=10}
post |>
  filter(par %in% c('psi', 'size_opt', 'size_var')) |>
  pivot_wider(
    names_from = par,
    values_from = value
  ) |>
  group_by(species_id) |>
  expand_grid(size = seq(10, 800, 20)) |>
  mutate(
    SizeEffect = -(log(size/size_opt)/size_var)^2,
    psi_size = exp(psi + SizeEffect)
  ) |>
  select(iter, species_id, size, SizeEffect, psi_size) |>
  pivot_longer(
    cols = c('SizeEffect', 'psi_size'),
    names_to = 'sim'
  ) |>
  mutate(
    sim = factor(sim, levels = c('SizeEffect', 'psi_size'), labels = c('DBH effect (log linear)', 'DBH effect on longetivity'))
  ) |>
  ggplot(aes(x = size, y = value, color = species_id)) +
    stat_lineribbon(.width = 0.95, alpha = .8) +
    facet_wrap(~sim, scales = 'free') +
    scale_fill_brewer() +
    xlab('DBH (mm)') +
    ylab('') +
    theme_minimal() +
    theme(legend.position = 'bottom')
```


## Plot competition effect

```{r BAeffect,echo=FALSE,warning=FALSE,message=FALSE,fig.height=8,fig.width=10}
post |>
  filter(par %in% c('psi', 'Beta', 'theta')) |>
  pivot_wider(
    names_from = par,
    values_from = value
  ) |>
  group_by(species_id) |>
  expand_grid(BA_comp = seq(0, 100, 5)) |>
  mutate(
    BAeffect_sp = BA_comp * Beta,
    BAeffect_intra = BA_comp * Beta * theta,
    psiBA_sp = exp(psi + BAeffect_sp),
    psiBA_intra = exp(psi + BAeffect_intra)
  ) |>
  filter(theta < 2) |> 
  select(iter, species_id, BA_comp, contains('BAeffect'), contains('psiBA')) |>
  pivot_longer(
    cols = c(contains('BAeffect'), contains('psiBA')),
    names_to = c('log', 'sim'),
    names_sep = '_'
  ) |>
  mutate(
    log = factor(
      log,
      levels = c('BAeffect', 'psiBA'),
      labels = c('Log linear effect of competition', 'longevity in function of competition')
    ),
    sim = factor(
      sim,
      levels = c('sp' ,'intra'),
      labels = c('Conspecific interactions', 'Heterospecific interactions')
    )
  ) |>
  ggplot(aes(x = BA_comp, y = value, color = species_id)) +
    stat_lineribbon(.width = 0.95, alpha = .8) +
    facet_wrap(~sim + log, scales = 'free') +
    scale_fill_brewer() +
    xlab('Basal area competition') +
    ylab('') +
    theme_minimal() +
    theme(legend.position = 'bottom')
```


## Mortality in function of fixed effects

```{r plot_preds,echo=FALSE,warning=FALSE,message=FALSE,fig.height=10,fig.width=12}
accur_ls <- mortProp_ls <- mortPropPlot_ls <- list()
for(Sp in spIds)
{
  train_sp <- trainData[species_id == Sp & sampled == 'training']

  # replicate each observation by N_iteration to accommodate the parameters draw
  # Using only 300 iterations of the 8000 to speed calculation as the final
  # result is quite similar to use the 8000 iteractions
  train_sp[, obsID := .I]
  train_sp <- train_sp[rep(obsID, each = 300)]
  sampledIter <- sample(1:(simInfo$maxIter/2 * simInfo$nC), 300)
  train_sp[, iter := sampledIter, by = obsID]

  # merge global parameters
  train_sp[
    post |>
        filter(species_id == Sp) |>
        select(-species_id) |>
        pivot_wider(names_from = par, values_from = value) |>
        setDT(),
    `:=`(
      psi = i.psi,
      sigma_plot = i.sigma_plot,
      size_opt = i.size_opt,
      size_var = i.size_var,
      Beta = i.Beta,
      theta = i.theta
    ),
    on = 'iter'
  ]
  
  # merge plot_id parameters if plot is present in validation data
  train_sp[
    readRDS(posteriorpsiPlot_files[Sp]) |>
      mutate(
        plot_id_seq = parse_number(par)
      ) |>
      select(!par) |>
      setDT(),
    psiPlot := i.value,
    on = c('iter', 'plot_id_seq')
  ]

  # merge plot_id parameters if plot is present in validation data
  train_sp[
    readRDS(posteriorpsiYearInt_files[Sp]) |>
      mutate(
        time_int = parse_number(par)
      ) |>
      select(!par) |>
      setDT(),
    psiYear := i.value,
    on = c('iter', 'time_int')
  ]

  # random iter were selected, create a new iter vetor to a proprer sequence
  # from 1 to nSample of iteration
  train_sp[, iter2 := 1:.N, by = obsID]

  # compute longevity logit
  train_sp[,
    longev_log := 1/(1 + exp(
        -(
          psi + 
          psiPlot +
          psiYear +
          -(log(dbh0/size_opt)/size_var)^2 +
          Beta * (BA_comp_sp + theta * BA_comp_intra)
        )
      )
    )
  ]

  # compute mortality rate in function of time
  train_sp[,
    mortality_prob := 1 - (longev_log^deltaYear)
  ]

  # predict mortality event
  train_sp[,
    mort_pred := rbinom(.N, size = 1, mortality_prob)
  ]

  # Compute model accuracy
  accur_ls[[Sp]] <- train_sp |>
    group_by(iter2) |>
    summarise(
      TP = sum(mort == 1 & mort_pred == 1),
      TN = sum(mort == 0 & mort_pred == 0),
      FN = sum(mort == 1 & mort_pred == 0),
      FP = sum(mort == 0 & mort_pred == 1)
    ) |>
    mutate(
      Acc = (TP + TN)/(TP + TN + FP + FN),
      Sensitivity = TP/(TP + FN),
      Specificity = TN/(FP + TN),
      AccCorrected = (Sensitivity + Specificity)/2
    ) |>
    bind_cols(species_id = Sp)

  # Compute proportion of mortality events (pred vs obs)
  mortProp_ls[[Sp]] <- train_sp |>
    group_by(iter2) |>
    summarise(
      mortProp_obs = sum(mort == 1)/n(),
      mortProp_pred = sum(mort_pred == 1)/n()
    ) |>
    bind_cols(species_id = Sp)

  mortPropPlot_ls[[Sp]] <- train_sp |>
    group_by(plot_id) |>
    summarise(
      mortProp_obs = sum(mort == 1)/n(),
      mortProp_pred = sum(mort_pred == 1)/n()
    ) |>
    bind_cols(species_id = Sp)


  # Prediction figures
  post_sp <- post |>
    filter(species_id == Sp) |>
    group_by(par) |>
    summarise(value = mean(value)) |>
    deframe()

  dt_p1 <- train_sp |>
    select(iter2, BA_comp_sp, mort, mort_pred) |>
    mutate(
      BAc = cut(
        BA_comp_sp,
        seq(min(BA_comp_sp), max(BA_comp_sp), length.out = 10),
        include.lowest = TRUE
      )
    ) |>
    group_by(BAc, iter2) |>
    summarise(
      Obs = sum(mort == 1)/n(),
      Pred = sum(mort_pred == 1)/n()
    ) |>
    pivot_longer(
      cols = c('Obs', 'Pred')
    )

  dt_p2 <- train_sp |>
    select(iter2, BA_comp_intra, mort, mort_pred) |>
    mutate(
      BAc = cut(
        BA_comp_intra,
        seq(min(BA_comp_intra), max(BA_comp_intra), length.out = 10),
        include.lowest = TRUE
      )
    ) |>
    group_by(BAc, iter2) |>
    summarise(
      Obs = sum(mort == 1)/n(),
      Pred = sum(mort_pred == 1)/n()
    ) |>
    pivot_longer(
      cols = c('Obs', 'Pred')
    )

# Prediction figures
  dt_p3 <- train_sp |>
    select(iter2, dbh0, mort, mort_pred) |>
    mutate(
      sizec = cut(
        dbh0,
        seq(min(dbh0, na.rm = TRUE), max(dbh0, na.rm = TRUE), length.out = 10),
        include.lowest = TRUE
      )
    ) |>
    group_by(sizec, iter2) |>
    summarise(
      Obs = sum(mort == 1)/n(),
      Pred = sum(mort_pred == 1)/n()
    ) |>
    pivot_longer(
      cols = c('Obs', 'Pred')
    )
    
  yLim = range(c(dt_p1$value, dt_p2$value, dt_p3$value))

  mort_prob = function(psi)
    return( 1 - ( (1/(1 + exp(-(psi))))^train_sp[, median(deltaYear)] ) )
  
  p1 <- dt_p1 |> 
    ggplot(aes(x = BAc, y = value, color = name)) +
      geom_boxplot(alpha = .4) +
      xlab('Conspecific basal area') +
      ylab('Mortality proportion') +
      labs(subtitle = Sp) +
      theme_minimal() +
      # geom_function(
      #   fun = function(x)
      #     mort_prob(post_sp['psi'] + x * post_sp['Beta']),
      #   color = 1,
      #   linetype = 'dashed'
      # ) +
      labs(color = '') +
      ylim(yLim)

  p2 <- dt_p2 |>
    ggplot(aes(x = BAc, y = value, color = name)) +
      geom_boxplot(alpha = .4) +
      xlab('Heterospecific basal area') +
      ylab('') +
      labs(subtitle = '') +
      theme_minimal() +
      # geom_function(
      #   fun = function(x)
      #     mort_prob(post_sp['psi'] + x * post_sp['Beta'] * post_sp['theta']),
      #   color = 1,
      #   linetype = 'dashed'
      # ) +
      labs(color = '') +
      ylim(yLim)

  p3 <- dt_p3 |>
    ggplot(aes(x = sizec, y = value, color = name)) +
      geom_boxplot(alpha = .4) +
      xlab('DBH (mm)') +
      ylab('Mortality proportion') +
      labs(subtitle = '') +
      theme_minimal() +
      # geom_function(
      #   fun = function(x)
      #     mort_prob(post_sp['psi'] - (log(x/post_sp['size_opt'])/post_sp['size_var'])^2),
      #   color = 1,
      #   linetype = 'dashed'
      # ) +
      labs(color = '') +
      ylim(yLim)

  print(
    ggarrange(
      p1, p2, p3,
      ncol = 2,
      nrow = 2,
      common.legend = TRUE,
      legend = 'bottom'
    )
  )
}

# save accuracy mortatality proportion to be used for model comparison
accur_ls |>
  bind_rows() |>
  saveRDS(file.path('output', simName, 'accuracy.RDS'))
mortProp_ls |>
  bind_rows() |>
  saveRDS(file.path('output', simName, 'mortProp.RDS'))
mortPropPlot_ls |>
  bind_rows() |>
  saveRDS(file.path('output', simName, 'mortPropPlot.RDS'))

```


## Accuracy

Using four different metrics:

- **Sensitivity** measures the percentage of dead trees that are identified as dead
- **Specificity** measures the percentage of alive trees that are correctly identified as alive
- **Accuracy** is the ratio of number of correct predictions to the total of predictions
- **Accuracy balanced** considers unbalanced accuracy predictions of positive and negative events (sensitivity and specificity)

```{r plot_accur, echo = FALSE, warning=FALSE, message=FALSE, fig.height = 13, fig.width = 9}
accur_ls |>
  bind_rows() |>
  select(species_id, iter2, Acc, Sensitivity, Specificity, AccCorrected) |>
  pivot_longer(
    cols = c(Acc, Sensitivity, Specificity, AccCorrected)
  ) |>
  mutate(
    name = recode_factor(
      name,
      Acc = 'Accuracy',
      AccCorrected = 'Accuracy corrected',
      Sensitivity = 'Sensitivity',
      Specificity = 'Specificity'
    )
  ) |>
  ggplot(aes(x = value, y = species_id)) +
    ggridges::geom_density_ridges2(color = NA, alpha = 0.8) +
    facet_wrap(~ name, scales = 'free_x') +
    theme_classic() +
    xlab('') + ylab('')
```


## Population level mortality rate

```{r plotMortProp,echo=F,warning=FALSE,message=FALSE,fig.height=8,fig.width=7}
propObs <- mortProp_ls |>
  bind_rows() |>
  group_by(species_id) |>
  summarise(mprop = unique(mortProp_obs))

mortProp_ls |>
  bind_rows() |>
  ggplot(aes(x = mortProp_pred, y = species_id)) +
    ggridges::geom_density_ridges2(color = NA) +
    geom_segment(
      data = propObs,
      aes(
        x = mprop, xend = mprop,
        y = 1:length(species_id),
        yend = (1:length(species_id)) + .8
      ),
      color = "red", alpha = 0.6
    ) +
    theme_classic() +
    xlab('Proportion of mortality events (obs in red vs predicted in grey)') +
    ylab('')
```

```{r plotMortProp2,echo=F,warning=FALSE,message=FALSE,fig.height=8,fig.width=10}
mortPropPlot_ls |>
  bind_rows() |>
  ggplot(aes(x = mortProp_obs, y = mortProp_pred)) +
    geom_point(size = .7, alpha = 0.6) +
    facet_wrap(~species_id) +
    geom_smooth(method = 'gam') +
    geom_abline(slope = 1, intercept = 0) +
    theme_classic() +
    xlab('Observerd mortality rate') +
    ylab('Predicted mortality rate')
```


# Out-of-bag cross-validation

```{r obbCrossValidation, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 9, fig.width = 9}
# As we are using each draw of the posterior distribution to predict the validation data, the dataset becames too big to store all species in memory.
# So I will loop over each species to (i) load dataset, (ii) predict for validation, (iii) compute prediction metrics and (iv) generate the plots

# list accuracy db for each species
accurOBB_ls <- mortPropOBB_ls <- mortPropPlotOBB_ls <- list()

# some species did not have enough data for spliting train and validation
# run only for species with validation data
spIds_val <- trainData[sampled == 'validation', unique(species_id)]
for(Sp in spIds_val)
{
  val_sp <- trainData[species_id == Sp & sampled == 'validation']

  # replicate each observation by N_iteration to accommodate the parameters draw
  # Using only 300 iterations of the 8000 to speed calculation as the final
  # result is quite similar to use the 8000 iteractions
  val_sp[, obsID := .I]
  val_sp <- val_sp[rep(obsID, each = 300)]
  sampledIter <- sample(1:(simInfo$maxIter/2 * simInfo$nC), 300)
  val_sp[, iter := sampledIter, by = obsID]

  # merge global parameters
  val_sp[
    post |>
        filter(species_id == Sp) |>
        select(-species_id) |>
        pivot_wider(names_from = par, values_from = value) |>
        setDT(),
    `:=`(
      psi = i.psi,
      sigma_plot = i.sigma_plot,
      size_opt = i.size_opt,
      size_var = i.size_var,
      Beta = i.Beta,
      theta = i.theta
    ),
    on = 'iter'
  ]
  
  # merge plot_id parameters if plot is present in validation data
  val_sp[
    readRDS(posteriorpsiPlot_files[Sp]) |>
      mutate(
        plot_id_seq = parse_number(par)
      ) |>
      select(!par) |>
      setDT(),
    psiPlot := i.value,
    on = c('iter', 'plot_id_seq')
  ]

  # for the plots not used in the fit model, generate the rPlot_log
  # value from the population distribution
  val_sp[
    is.na(plot_id_seq),
    psiPlot := rnorm(.N, 0, sigma_plot)
  ]

  # merge plot_id parameters if plot is present in validation data
  val_sp[
    readRDS(posteriorpsiYearInt_files[Sp]) |>
      mutate(
        time_int = parse_number(par)
      ) |>
      select(!par) |>
      setDT(),
    psiYear := i.value,
    on = c('iter', 'time_int')
  ]
  
  # random iter were selected, create a new iter vetor to a proprer sequence
  # from 1 to nSample of iteration
  val_sp[, iter2 := 1:.N, by = obsID]

  # compute longevity logit
  val_sp[,
    longev_log := 1/(1 + exp(
        -(
          psi + 
          psiPlot +
          psiYear +
          -(log(dbh0/size_opt)/size_var)^2 +
          Beta * (BA_comp_sp + theta * BA_comp_intra)
        )
      )
    )
  ]

  # compute mortality rate in function of time
  val_sp[,
    mortality_prob := 1 - (longev_log^deltaYear)
  ]

  # predict mortality event
  val_sp[,
    mort_pred := rbinom(.N, size = 1, mortality_prob)
  ]

  # Compute model accuracy
  accurOBB_ls[[Sp]] <- val_sp |>
    group_by(iter2) |>
    summarise(
      TP = sum(mort == 1 & mort_pred == 1),
      TN = sum(mort == 0 & mort_pred == 0),
      FN = sum(mort == 1 & mort_pred == 0),
      FP = sum(mort == 0 & mort_pred == 1)
    ) |>
    mutate(
      Acc = (TP + TN)/(TP + TN + FP + FN),
      Sensitivity = TP/(TP + FN),
      Specificity = TN/(FP + TN),
      AccCorrected = (Sensitivity + Specificity)/2
    ) |>
    bind_cols(species_id = Sp)

  # Compute proportion of mortality events (pred vs obs)
  mortPropOBB_ls[[Sp]] <- val_sp |>
    group_by(iter2) |>
    summarise(
      mortProp_obs = sum(mort == 1)/n(),
      mortProp_pred = sum(mort_pred == 1)/n()
    ) |>
    bind_cols(species_id = Sp)

  mortPropPlotOBB_ls[[Sp]] <- val_sp |>
    group_by(plot_id) |>
    summarise(
      mortProp_obs = sum(mort == 1)/n(),
      mortProp_pred = sum(mort_pred == 1)/n()
    ) |>
    bind_cols(species_id = Sp)
}

# save accuracy to be used for model comparison
accurOBB_ls |>
  bind_rows() |>
  saveRDS(file.path('output', simName, 'accuracy_oob.RDS'))
mortPropOBB_ls |>
  bind_rows() |>
  saveRDS(file.path('output', simName, 'mortProp_oob.RDS'))
mortPropPlotOBB_ls |>
  bind_rows() |>
  saveRDS(file.path('output', simName, 'mortPropPlot_oob.RDS'))
```

```{r plot_accurOOB, echo = FALSE, warning=FALSE, message=FALSE, fig.height = 13, fig.width = 9}

sim_toLoad <- c(simInfo$simCompare, simName)
map_dfr(
  sim_toLoad,
  ~ readRDS(paste0('output/', .x, '/accuracy_oob.RDS')) |>
    bind_cols(sim = .x)
) |>
  select(species_id, iter2, sim, Acc, Sensitivity, Specificity, AccCorrected) |>
  pivot_longer(
    cols = c(Acc, Sensitivity, Specificity, AccCorrected)
  ) |>
  mutate(
    name = recode_factor(
      name,
      Acc = 'Accuracy',
      AccCorrected = 'Accuracy corrected',
      Sensitivity = 'Sensitivity',
      Specificity = 'Specificity'
    )
  ) |>
  ggplot(aes(x = value, y = species_id, fill = sim)) +
    ggridges::geom_density_ridges2(alpha = 0.5, color = NA) +
    facet_wrap(~ name, scales = 'free_x') +
    theme_classic() +
    xlab('') + ylab('') +
    theme(legend.position = 'bottom')
```


## OOB population level mortality rate

```{r plotMortPropOBB,echo=F,warning=FALSE,message=FALSE,fig.height=8,fig.width=7}
propObs <- mortPropOBB_ls |>
  bind_rows() |>
  group_by(species_id) |>
  summarise(mprop = unique(mortProp_obs)) |>
  mutate(sim = NA)

map_dfr(
  sim_toLoad,
  ~ readRDS(paste0('output/', .x, '/mortProp_oob.RDS')) |>
    bind_cols(sim = .x)
  ) |>
  ggplot(aes(x = mortProp_pred, y = species_id, fill = sim)) +
    ggridges::geom_density_ridges2(alpha = 0.5, color = NA) +
    geom_segment(
      data = propObs,
      aes(
        x = mprop, xend = mprop,
        y = 1:length(species_id),
        yend = (1:length(species_id)) + .8
      ),
      color = "red", alpha = 0.6
    ) +
    theme_classic() +
    xlab('Proportion of mortality events (obs in red vs predicted in grey)') +
    ylab('') +
    theme(legend.position = 'bottom')
```

```{r plotMortProp2OBB,echo=F,warning=FALSE,message=FALSE,fig.height=8,fig.width=10}
mortPropPlotOBB_ls |>
  bind_rows() |>
  ggplot(aes(x = mortProp_obs, y = mortProp_pred)) +
    geom_point(size = 0.7, alpha = 0.6) +
    facet_wrap(~species_id, scales = 'free') +
    geom_smooth(method = 'gam') +
    geom_abline(slope = 1, intercept = 0) +
    theme_classic() +
    xlab('Observerd mortality rate') +
    ylab('Predicted mortality rate')
```


# Leave-one-out cross-validation to compare models

```{r loo, echo = FALSE, warning=FALSE,fig.height = 8, fig.width = 8, warning=FALSE, message=FALSE}
map_dfr(
    spIds,
    ~ map2(
        setNames(sim_toLoad, sim_toLoad),
        .x,
        ~ readRDS(paste0('output/', .x, '/loo_', .y, '.RDS'))
      ) |>
      loo::loo_compare() |>
      as.data.frame() |>
      bind_cols(species_id = .x) |>
      rownames_to_column(var = 'sim')
  ) |>
  select(species_id, sim, elpd_diff, se_diff) |>
  pivot_longer(
    cols = c(elpd_diff, se_diff),
    names_to = 'variable',
    values_to = 'value'
  ) |>
  ggplot(aes(x = value, y = species_id, color = sim)) +
    geom_point() +
    facet_wrap(~ variable, scales = 'free_x') +
    xlab('') + ylab('') +
    theme_bw() +
    theme(legend.position = 'bottom')
```

```{r loo2, echo = FALSE, warning=FALSE,fig.height = 4, fig.width = 8, warning=FALSE, message=FALSE}
map_dfr(
    spIds,
    ~ map2(
        setNames(sim_toLoad, sim_toLoad),
        .x,
        ~ readRDS(paste0('output/', .x, '/loo_', .y, '.RDS'))
      ) |>
      loo::loo_compare() |>
      as.data.frame() |>
      bind_cols(species_id = .x) |>
      rownames_to_column(var = 'sim')
  ) |>
  select(species_id, sim, elpd_diff, se_diff) |>
  pivot_longer(
    cols = contains('diff')
  ) |>
  ggplot(aes(y = sim, x = value)) +
    geom_boxplot() +
    facet_wrap(~name) +
    theme_bw()
```


# Sampling time

```{r plot sampling time, echo = FALSE, fig.height = 7, fig.width = 8}
map2_dfr(
  diag_files,
  names(diag_files),
  ~ readRDS(.x)[['time']][['chains']] |>
    bind_cols(species_id = .y)
) |>
ggplot(aes(x = total/3600, y = species_id)) +
  geom_boxplot() +
  xlab('Fit time (hours)') +
  theme_minimal()
```

---
 title: "MCMC diagnostics - recruitment"
 subtitle: "Test v8.0 - Zero inflated ingrowth model accounting for ingrowth and mortality of new individuals with plot random effect and basal area efffects on ingrowth rate `m`"
 author: "Will Vieira"
 date: "`r paste('Last updated on', format(Sys.time(), '%d %B, %Y'))`"
---

```{r, echo = F, message=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(cmdstanr))
suppressPackageStartupMessages(library(loo))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(tidybayes))
suppressPackageStartupMessages(library(bayesplot))
suppressPackageStartupMessages(library(ggridges))
suppressPackageStartupMessages(require(RColorBrewer))
suppressPackageStartupMessages(library(DT))
```
```{r load simulations, echo = F}
# Load simulation variables
simInfo <- yaml::read_yaml('_simulation_info.yml')

spIds <- simInfo$spIds
simName <- simInfo$simName
simulations <- simInfo$simulations

# List output files and set vector names to species_id
posteriorPop_files <- grep(
  'posteriorPop',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(posteriorPop_files) <- names(sort(sapply(spIds, function(x) grep(x, posteriorPop_files))))

posteriormPlot_files <- grep(
  'posteriormPlot',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(posteriormPlot_files) <- names(sort(sapply(spIds, function(x) grep(x, posteriormPlot_files))))


diag_files <- grep(
  'diagnostics',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(diag_files) <- names(sort(sapply(spIds, function(x) grep(x, diag_files))))

toSub_files <- grep(
  'toSub',
  dir(file.path('output', simName), full.names = TRUE),
  value = TRUE
)
names(toSub_files) <- names(sort(sapply(spIds, function(x) grep(x, toSub_files))))
```


```{r load dataset,echo =FALSE}
fec_dt <- readRDS('data/fec_dt.RDS')
fec_dt <- fec_dt[species_id %in% spIds]

plot_summary <- fec_dt[,  
  .( 
    latitude = unique(latitude), 
    BA_plot = mean(BA_plot, na.rm = TRUE), 
    BA_adult = mean(BA_adult, na.rm = TRUE),
    bio_01_mean = mean(bio_01_mean, na.rm = TRUE), 
    bio_12_mean = mean(bio_12_mean, na.rm = TRUE) 
  ),  
  by = plot_id  
]
```

# Rhat

```{r, echo = F,fig.height = 7, fig.width = 7}
map2_dfr(
  diag_files,
  names(diag_files),
  ~ readRDS(.x)[['rhat']] |>
      bind_cols(species_id = .y)
) |>
ggplot(aes(x = rhat, y = species_id)) +
  geom_boxplot() +
  theme_minimal()
```

# Divergent transitions

```{r divergentTransitions, echo = FALSE}
map2_dfr(
  diag_files,
  names(diag_files),
  ~ readRDS(.x)[['diag_summary']]['num_divergent'] |>
      bind_cols(species_id = .y) |>
      mutate(chain = row_number())
) |>
pivot_wider(
  names_from = chain,
  values_from = num_divergent,
  names_prefix = 'chain '
) |>
DT::datatable()
```

# Posterior distribution of parameters

```{r posteriorDist, eval = TRUE,echo = F, fig.height = 7, fig.width = 8}
post <- map2_dfr(
  posteriorPop_files,
  names(posteriorPop_files),
  ~ readRDS(.x) |>
    bind_cols(species_id = .y)
)

for(Par in unique(post$par))
{
  print(
    post |>
      filter(par == Par) |>
      ggplot(aes(x = value, y = species_id)) +
        stat_eye() +
        ggtitle(Par) +
        xlab('') +
        theme_minimal()
  )
}
```

# Correlation between parameters

```{r parCorrelation, eval = TRUE,echo = F, fig.height = 8, fig.width = 8}
parComb <- post |>
  summarise(uqPar = unique(par)) |>
  pull(uqPar) |>
  combn(2)

for(i in 1:ncol(parComb))
{
  print(
    post |>
      filter(par %in% parComb[, i]) |>
      filter(iter %in% sample(iter, 1000)) |>
      select(par, value, iter, species_id) |>
      pivot_wider(names_from = par, values_from = value) |>
      ggplot(aes_string(x = parComb[1, i], y = parComb[2, i])) + 
          geom_point() +
          facet_wrap(~ species_id) +
          xlab(parComb[1, i]) +
          ylab(parComb[2, i]) +
          theme_minimal()
  )
}
```


# Plot random effect

```{r plot_randomEffect, eval = TRUE, warning=FALSE, message=FALSE,echo = F, fig.height = 8, fig.width = 8}
plotEffect_ls <- list()
for(Sp in spIds)
{
  m_pop <- post |>
    filter(species_id == Sp & par == 'mPop_log') |>
    mutate(mPop_log = value) |>
    select(mPop_log, iter)

  m_mean <- m_pop |>
    summarise(m_mean = mean(exp(mPop_log))) |>
    pull(m_mean)

  toSub_sp <- readRDS(toSub_files[Sp]) |>
    left_join(
      plot_summary
    )

  dt_toPlot <- readRDS(posteriormPlot_files[Sp]) |>
    mutate(plot_id_seq = parse_number(par)) |>
    left_join(
      m_pop
    ) |>
    mutate(m = exp(value + mPop_log)) |>
    left_join(
      toSub_sp
    )

  # save plot effect mean to plot against other variables
  # in the next code block
  plotEffect_ls[[Sp]] <- dt_toPlot |>
    group_by(par) |>
    mutate(
      m_mean = mean(m),
      m_pop = exp(mPop_log)
    ) |>
    ungroup() |>
    filter(iter == 1) |>
    select(
      plot_id, plot_id_seq, m_mean, m_pop, latitude,
      BA_plot, BA_adult, bio_01_mean, bio_12_mean
    )
  
  # filter to remove some plots so figure is liseable
  dt_toPlot <- dt_toPlot |>
    filter(plot_id_seq %in% sample(plot_id_seq, 500)) |>
    mutate(plot_id = fct_reorder(plot_id, latitude))

  print(
    ggarrange(
      dt_toPlot |>
        ggplot(aes(y = plot_id, x = m, color = bio_01_mean)) +
          stat_pointinterval(alpha = .7, size = .1) +
          geom_vline(
            xintercept = m_mean, color = 'red', alpha = .8
          ) +
          xlab('m') + ylab('plot_id (ordered by latitude)') +
          theme_minimal() +
          theme(
            legend.position = 'top',
            axis.text.y = element_blank()
          ) +
          labs(subtitle = Sp),
      dt_toPlot |>
        ggplot(aes(y = plot_id, x = m, color = BA_adult)) +
          stat_pointinterval(alpha = .7, size = .1) +
          geom_vline(
            xintercept = m_mean, color = 'red', alpha = .8
          ) +
          xlab('m') + ylab('') +
          theme_minimal() +
          theme(
            legend.position = 'top',
            axis.text.y = element_blank()
          ) +
          labs(subtitle = ''),
      ncol = 2
    )
  )
}

# save plot effect ot be used against future models
plotEffect_ls |>
  bind_rows(.id = 'species_id') |>
  select(species_id, plot_id, m_mean) |>
  saveRDS(
    file.path(
        'output', 
        simName,
        'meanPlotEffect_m.RDS'
    )
  )

```


## Plot random effect in function of annual mean temperature and basal area

```{r plot_randomEffect2, eval = TRUE, warning=FALSE, message=FALSE,echo = F, fig.height = 8, fig.width = 12}
# merge list of sepecies
plotEffect <- plotEffect_ls |>
  bind_rows(.id = 'species_id')

m_pop <- plotEffect |>
  group_by(species_id) |>
  summarise(m = unique(m_pop))

print(
  plotEffect |>
    ggplot(aes(x = bio_01_mean, log(m_mean), color = BA_adult)) +
        geom_point(size = 0.4, alpha = 0.8) +
        facet_wrap(~species_id, scales = 'free') +
        geom_hline(data = m_pop, aes(yintercept = log(m)), color = 'red') +
        xlab('Annual mean temperature') +
        ylab('Plot random effect') +
        theme_minimal()
)
print(
  plotEffect |>
    mutate(
      db_origin = as.factor(ifelse(grepl('\\.', plot_id), 'FIA', 'Quebec'))
    ) |>
    ggplot(aes(x = BA_adult, log(m_mean), color = db_origin)) +
        geom_point(size = 0.6, alpha = 0.5) +
        facet_wrap(~species_id, scales = 'free') +
        geom_hline(data = m_pop, aes(yintercept = log(m)), color = 'red') +
        xlab('Plot basal area') +
        ylab('Plot random effect') +
        theme_minimal()
)
print(
  plotEffect |>
    ggplot(aes(x = bio_12_mean, log(m_mean), color = BA_adult)) +
        geom_point(size = 0.6) +
        facet_wrap(~species_id, scales = 'free') +
        geom_hline(data = m_pop, aes(yintercept = log(m)), color = 'red') +
        xlab('Total annual precipitation') +
        ylab('Plot random effect') +
        theme_minimal()
)
```


# Changes in plot random effect from past models

Compare plot random effect with last model to check how variance is changing.

```{r compare_rReal, echo = FALSE, warning=FALSE, message=FALSE, fig.height = 8, fig.width = 12}
sim_toLoad <- c(simInfo$simCompare[length(simInfo$simCompare)], simName)
map_dfr(
    sim_toLoad,
    ~ readRDS(file.path('output', .x, 'meanPlotEffect_m.RDS')) |>
      bind_cols(sim = .x)
  ) |>
  pivot_wider(
    names_from = sim,
    values_from = m_mean
  ) |>
  ggplot(aes(x = !!sym(sim_toLoad[1]), y = !!sym(sim_toLoad[2]))) +
    geom_point(size = 0.8, alpha = .7) +
    geom_abline(intercept = 0, slope = 1) +
    #tune::coord_obs_pred() +
    facet_wrap(~species_id, scales = 'free') +
    theme_minimal()
```


# Data distribution

```{r organize data, echo = FALSE, warning=FALSE, message=FALSE, fig.height = 7, fig.width = 8}
fec_dt[, .(species_id, nbRecruit, deltaYear_plot, BA_adult)] |>
  pivot_longer(
    cols = c(nbRecruit, deltaYear_plot, BA_adult),
    names_to = 'var'
  ) |>
  ggplot(aes(x = value, y = species_id)) +
    geom_density_ridges(alpha = 0.7, color = NA) +
    facet_wrap(~var, scales = 'free_x') +
    xlab('') +
    theme_minimal()
```


# Predictions

## Ingrowth in function of time

```{r,echo=FALSE,fig.height = 6.5, fig.width = 8}
post |>
  pivot_wider(
    names_from = par,
    values_from = value
  ) |>
  group_by(species_id) |>
  expand_grid(deltaYear = seq(0, 50, .5)) |>
  mutate(
    lambda = exp(mPop_log) * 399 * (1 - p^deltaYear)/(1 - p)
  ) |>
  ggplot(aes(x = deltaYear, y = lambda, color = species_id)) +
        stat_lineribbon(.width = 0.95, alpha = .8) +
        scale_fill_brewer() +
        theme_minimal() +
        #theme(legend.position="none") +
        ylab('Number of ingrowth recruits') + xlab('Delta time (years)')
```

## Basal area effect

```{r sizePred2,echo=FALSE,fig.height = 8, fig.width = 10}
post |>
  filter(par %in% c('mPop_log', 'beta')) |>
  pivot_wider(
    names_from = par,
    values_from = value
  ) |>
  group_by(species_id) |>
  expand_grid(BA_adult = seq(0, 120, 5)) |>
  mutate(
    BAeffect = BA_adult * beta,
    m = exp(mPop_log + BAeffect)
  ) |>
  select(iter, species_id, BA_adult, BAeffect, m) |>
  pivot_longer(
    cols = c('BAeffect', 'm'),
    names_to = 'sim'
  ) |>
  mutate(
    sim = factor(sim, levels = c('BAeffect', 'm'), labels = c('BA_adult effect on m parameter', 'm parameter'))
  ) |>
  ggplot(aes(x = BA_adult, y = value, color = species_id)) +
    stat_lineribbon(.width = 0.95, alpha = .8) +
    facet_wrap(~sim, scales = 'free') +
    scale_fill_brewer() +
    xlab('Basal area competition') +
    ylab('') +
    theme_minimal() +
    theme(legend.position = 'bottom')
    
```


## Ingrowth in function of Basal area of adults

```{r BApred,echo=FALSE, warning=FALSE, message=FALSE,fig.height = 4.5, fig.width = 9}
# prepare parameters
post_mean <- post |>
  filter(par %in% c('mPop_log', 'p', 'beta')) |>
  group_by(species_id, par) |>
  summarise(value_mean = mean(value)) |>
  pivot_wider(
    names_from = par,
    values_from = value_mean
  ) |>
  setDT()

# plot per species_id
for(sp_seq in seq(1, 17, 2)) 
{
  plot_ls <- list()
  for(i in 0:1)
  {
    if(sp_seq == 17 & i == 1)
      next

    Sp <- spIds[sp_seq + i]

    fec_sp <- fec_dt[species_id == Sp]

    # add parameters
    fec_sp[,
      c('beta', 'mPop_log', 'p') := post_mean[
        species_id == Sp,
        .(beta, mPop_log, p)
      ]
    ]

    fec_sp[
      plotEffect |>
        filter(species_id == Sp) |>
        select(-species_id) |>
        setDT(),
      m_mean := i.m_mean,
      on = 'plot_id'
    ]

    # compute BA effect on m
    fec_sp[, m_plotBA := exp(log(m_mean) + BA_adult * beta)]
    
    # predict recruit
    fec_sp[,
      pred_nbRecruit := m_plotBA *
                  plot_size *
                  (1 - p^deltaYear_plot)/(1 - p)
    ]

    fec_sp[,
      pred_nbRecruit_random := rpois(.N, pred_nbRecruit)
    ]

    # plot
    plot_ls[[i+1]] <- fec_sp |>
        filter(!is.na(pred_nbRecruit)) |>
        mutate(
          obs_nbRecruit = nbRecruit
        ) |>
        select(BA_adult, obs_nbRecruit, pred_nbRecruit_random) |>
        pivot_longer(
          cols = contains('Recruit'),
          names_to = 'sim'
        ) |>
        ggplot(aes(x = BA_adult, y = value, color = sim)) +
          geom_point(alpha = .5, size = .5) +
          geom_smooth(method = 'gam') +
          xlab('Basal area of adults') +
          ylab(ifelse(i == 0, 'nbRecruit', '')) +
          labs(subtitle = Sp) +
          theme_minimal()
  }
  print(
    ggpubr::ggarrange(plotlist = plot_ls, ncol = 2, legend = 'right', common.legend = TRUE)
  )
}
```


# Cross-validation

```{r crossValidation, echo=FALSE, warning=FALSE, message=FALSE, fig.height =4.5, fig.width = 9}
# As we are using each draw of the posterior distribution to predict the validation data, the dataset becames too big to store all species in memory.
# So I will loop over each species to (i) load dataset, (ii) predict for validation, (iii) compute prediction metrics and (iv) generate the plots

# list to save MSE and R2 for each species to be used later
MSE_list <- R2_list <- list()

for(Sp in spIds)
{
  val_sp <- fec_dt[species_id == Sp]

  # merge plot_id sequence
  val_sp[
    readRDS(toSub_files[Sp]),
    plot_id_seq := i.plot_id_seq,
    on = 'plot_id'
  ]

  # remove NAs
  val_sp <- val_sp[
    !is.na(BA_adult),
    .(
      plot_id, plot_id_seq, species_id, nbRecruit, deltaYear_plot,
      plot_size, BA_adult, relativeBA_adult_sp
    )
  ]

  # replicate each observation by N_iteration to accommodate the parameters draw
  # Using only 1k iterations of the 8000
  val_sp[, obsID := .I]
  val_sp <- val_sp[rep(obsID, each = 200)]
  sampledIter <- sample(1:(simInfo$maxIter/2 * simInfo$nC), 200)
  val_sp[, iter := sampledIter, by = obsID]

  # merge global parameters
  val_sp[
    post |>
        filter(species_id == Sp) |>
        select(-species_id) |>
        pivot_wider(names_from = par, values_from = value) |>
        setDT(),
    `:=`(
      mPop_log = i.mPop_log,
      p = i.p,
      sigma_plot = i.sigma_plot,
      beta = i.beta,
      theta = i.theta
    ),
    on = 'iter'
  ]

  # merge plot specific parameters
  val_sp[
    readRDS(posteriormPlot_files[Sp]) |>
      mutate(
        plot_id_seq = parse_number(par)
      ) |>
      select(iter, plot_id_seq, value) |>
      setDT(),
    mPlot_log := i.value,
    on = c('iter', 'plot_id_seq')
  ]

  # random iter were selected, create a new iter vetor to a proprer sequence
  # from 1 to nSample of iteration
  val_sp[, iter2 := 1:.N, by = obsID]

  # compute m plot specific parameter with BA effect
  val_sp[,
    m := exp(
      mPop_log + mPlot_log +
      BA_adult * beta
    )
  ]

  # predict number of recruit
  val_sp[,
    lambda :=  m *
               plot_size *
               (1 - p^deltaYear_plot)/(1 - p)
  ]

  # simulate nbRecruit from model distribution (Poisson dist)
  # random recruit evenement given theta prob
  val_sp[, zero_recruit := rbernoulli(.N, p = theta)]

  # recruit only if is non zero recruit
  val_sp[, nbRecruit_random := ifelse(zero_recruit, 0, NA)]
  val_sp[is.na(nbRecruit_random), nbRecruit_random := rpois(.N, lambda)]

  # calculate MSE
  val_sp[, SE := (nbRecruit - nbRecruit_random)^2]
  
  # mean SE over all observations for each iteration and save to list
  MSE_list[[Sp]] <- val_sp[, 
    .(
      MSE = mean(SE, na.rm = TRUE),
      species_id = Sp
    ),
    by = iter2
  ]

  # Calculate R2 (Gelman et al 2018)
  R2gel <- val_sp |>
    group_by(iter2) |>
    summarise(
      var_lambda = var(lambda, na.rm = TRUE),
      mean_lambda = mean(lambda, na.rm = TRUE)      
    ) |>
    bind_cols(
      iter = sampledIter,
      species_id = Sp
    ) |>
    mutate(
      R2gelman = var_lambda/(var_lambda + mean_lambda)
    ) |>
    select(iter, iter2, species_id, R2gelman) |>
    setDT()

  # calculate R2 from regression linear model using the 1:1 obs vs pred
  get_r2 <- function(x, y)
      return(summary(lm(y~x))$r.squared)
  
  R2_list[[Sp]] <- merge(
    R2gel,
    val_sp[,
      .(
        R2reg = get_r2(nbRecruit, nbRecruit_random),
        R2reg_mean = get_r2(nbRecruit, lambda)
      ), 
      by = iter2
    ],
    by = 'iter2'
  )

  # plot
  p1 <- val_sp[,.(m_obs=mean(nbRecruit), m_pred=mean(lambda)), by = obsID] |>
    ggplot(aes(m_obs, m_pred)) +
          geom_point(alpha = .3, size = .5) +
          geom_abline(slope = 1, intercept = 0) + 
          tune::coord_obs_pred() +
          theme_minimal() +
          theme(
                legend.position="none",
                plot.margin = margin(t = 30)
            ) +
          xlab('Observerd nbRecruit') +
          ylab('Predicted nbRecruit')


  pred_matrix <- val_sp[, .(nbRecruit_random, iter2, obsID)] |>
      pivot_wider(names_from = obsID, values_from = nbRecruit_random) |>
      select(-iter2) |>
      as.matrix()

  xLim_max <- val_sp[, quantile(nbRecruit, probs = 0.99) + 1]
  p2 <- ppc_dens_overlay(
      val_sp[iter2 == 1, nbRecruit],
      pred_matrix[sample(1:nrow(pred_matrix), 200), ]
  ) +
  xlim(0, xLim_max) +
  xlab('nbRecruit')

  print(
    ggpubr::ggarrange(
        p1, p2,
        ncol = 2,
        labels = Sp,
        font.label = list(size = 9, face = 'bold')
    )
  )
}

# save MSE and R2 to be used for model comparison
invisible(
    map_dfr(
    c('MSE', 'R2'),
    ~ get(paste0(.x, '_list')) |>
        bind_rows() |>
        saveRDS(file = file.path(
          'output', 
          simName,
          paste0(.x, '.RDS')
      )
    )
  )
)
```


# Mean squared error (MSE)

```{r plot_MSE, echo = FALSE, warning=FALSE, message=FALSE, fig.height = 7, fig.width = 8}
sim_toLoad <- c(simInfo$simCompare, simName)

map_dfr(
    sim_toLoad,
    ~ readRDS(file.path('output', .x, 'MSE.RDS')) |>
      bind_cols(sim = .x)
  ) |>
  ggplot(aes(x = MSE, y = species_id, fill = sim)) +
    geom_density_ridges(alpha = 0.8, scale= 1.8, color = NA) +
    xlab('Mean Squared error (MSE)') + ylab('') +
    theme_minimal()
```


# Rsquared

The distribution of R squared values is calculated using the Gelman et al. [2018](http://www.stat.columbia.edu/~gelman/research/unpublished/bayes_R2.pdf) definition.

```{r plot Rsquared_gelman,echo=FALSE,fig.height = 7, fig.width = 8, warning=FALSE, message=FALSE}
map_dfr(
    sim_toLoad,
    ~ readRDS(file.path('output', .x, 'R2.RDS')) |>
      bind_cols(sim = .x)
  ) |>
  ggplot(aes(x = R2gelman, y = species_id, fill = sim)) +
      geom_density_ridges(alpha = 0.8, scale= 1.8, color = NA) +
      xlab('Rsquared (Gelman 2018)') +
      theme_minimal()
```

We also calculated the $R^2$ from the linear model using the 1:1 plot comparing observed values to the predicted values.

```{r plot Rsquared_regression,echo=FALSE,fig.height = 7, fig.width = 8, warning=FALSE, message=FALSE}
map_dfr(
    sim_toLoad,
    ~ readRDS(file.path('output', .x, 'R2.RDS')) |>
      bind_cols(sim = .x)
  ) |>
  ggplot(aes(x = R2reg, y = species_id, fill = sim)) +
    geom_density_ridges(alpha = 0.8, scale= 1.8, color = NA) +
    xlab('Rsquared (linear regression)') +
    theme_minimal()
```


# Leave-one-out cross-validation to compare models

```{r loo, echo = FALSE, warning=FALSE,fig.height = 8, fig.width = 8, warning=FALSE, message=FALSE}
map_dfr(
    spIds,
    ~ map2(
        setNames(sim_toLoad, sim_toLoad),
        .x,
        ~ readRDS(paste0('output/', .x, '/loo_', .y, '.RDS'))
      ) |>
      loo::loo_compare() |>
      as.data.frame() |>
      bind_cols(species_id = .x) |>
      rownames_to_column(var = 'sim')
  ) |>
  select(species_id, sim, elpd_diff, se_diff) |>
  pivot_longer(
    cols = c(elpd_diff, se_diff),
    names_to = 'variable',
    values_to = 'value'
  ) |>
  ggplot(aes(x = value, y = species_id, color = sim)) +
    geom_point() +
    facet_wrap(~ variable, scales = 'free_x') +
    xlab('') + ylab('') +
    theme_bw() +
    theme(legend.position = 'bottom')
```

# Sampling time

```{r plot sampling time, echo = FALSE, fig.height = 7, fig.width = 8}
map2_dfr(
  diag_files,
  names(diag_files),
  ~ readRDS(.x)[['time']][['chains']] |>
    bind_cols(species_id = .y)
) |>
ggplot(aes(x = total/3600, y = species_id)) +
  geom_boxplot() +
  xlab('Fit time (hours)') +
  theme_minimal()
```